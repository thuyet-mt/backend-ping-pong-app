package handlers


























































































































































































































































































































































































































}	})		"version": "2.0.0",		"message": "üèì Ping Pong Backend is running!",		"status":  "ok",	c.JSON(http.StatusOK, gin.H{func healthCheck(c *gin.Context) {// ==================== Health Check ====================}	sendSuccess(c, match, http.StatusOK)	}		return		}			sendError(c, errors.DatabaseError(err))		} else {			sendError(c, appErr)		if appErr, ok := err.(*errors.AppError); ok {	if err != nil {	match, err := svc.RecordMatchResult(matchID, req)	}		return		sendError(c, errors.InvalidInput(err.Error()))	if err := c.ShouldBindJSON(&req); err != nil {	var req models.RecordMatchResultRequest	matchID := c.Param("id")func handleRecordMatchResult(c *gin.Context, svc *service.Service) {}	sendSuccess(c, match, http.StatusCreated)	}		return		}			sendError(c, errors.DatabaseError(err))		} else {			sendError(c, appErr)		if appErr, ok := err.(*errors.AppError); ok {	if err != nil {	match, err := svc.CreateMatch(req)	}		return		sendError(c, errors.InvalidInput(err.Error()))	if err := c.ShouldBindJSON(&req); err != nil {	var req models.CreateMatchRequestfunc handleCreateMatch(c *gin.Context, svc *service.Service) {}	sendSuccess(c, matches, http.StatusOK)	}		return		}			sendError(c, errors.DatabaseError(err))		} else {			sendError(c, appErr)		if appErr, ok := err.(*errors.AppError); ok {	if err != nil {	matches, err := svc.GetMatchesByFixtureID(fixtureID)	fixtureID := c.Param("id")func handleGetMatchesByFixtureID(c *gin.Context, svc *service.Service) {// ==================== Match Handlers ====================}	sendSuccess(c, fixture, http.StatusCreated)	}		return		}			sendError(c, errors.DatabaseError(err))		} else {			sendError(c, appErr)		if appErr, ok := err.(*errors.AppError); ok {	if err != nil {	fixture, err := svc.CreateFixture(req)	}		return		sendError(c, errors.InvalidInput(err.Error()))	if err := c.ShouldBindJSON(&req); err != nil {	var req models.CreateFixtureRequestfunc handleCreateFixture(c *gin.Context, svc *service.Service) {}	sendSuccess(c, fixtures, http.StatusOK)	}		return		}			sendError(c, errors.DatabaseError(err))		} else {			sendError(c, appErr)		if appErr, ok := err.(*errors.AppError); ok {	if err != nil {	fixtures, err := svc.GetFixturesBySeasonID(seasonID)	seasonID := c.Param("id")func handleGetFixturesBySeasonID(c *gin.Context, svc *service.Service) {// ==================== Fixture Handlers ====================}	sendSuccess(c, logs, http.StatusOK)	}		return		}			sendError(c, errors.DatabaseError(err))		} else {			sendError(c, appErr)		if appErr, ok := err.(*errors.AppError); ok {	if err != nil {	logs, err := svc.GetPointLogs(playerSeasonID)	playerSeasonID := c.Param("playerSeasonId")func handleGetPointLogs(c *gin.Context, svc *service.Service) {}	sendSuccess(c, gin.H{"message": "ƒêi·ªÉm ƒë√£ ƒë∆∞·ª£c ƒëi·ªÅu ch·ªânh"}, http.StatusOK)	}		return		}			sendError(c, errors.DatabaseError(err))		} else {			sendError(c, appErr)		if appErr, ok := err.(*errors.AppError); ok {	if err != nil {	err := svc.AdjustPoints(req)	}		return		sendError(c, errors.InvalidInput(err.Error()))	if err := c.ShouldBindJSON(&req); err != nil {	var req models.AdjustPointsRequestfunc handleAdjustPoints(c *gin.Context, svc *service.Service) {// ==================== Point Handlers ====================}	sendSuccess(c, leaderboard, http.StatusOK)	}		return		}			sendError(c, errors.DatabaseError(err))		} else {			sendError(c, appErr)		if appErr, ok := err.(*errors.AppError); ok {	if err != nil {	leaderboard, err := svc.GetLeaderboard(seasonID)	seasonID := c.Param("id")func handleGetLeaderboard(c *gin.Context, svc *service.Service) {// ==================== Leaderboard Handlers ====================}	sendSuccess(c, playerSeason, http.StatusCreated)	}		return		}			sendError(c, errors.DatabaseError(err))		} else {			sendError(c, appErr)		if appErr, ok := err.(*errors.AppError); ok {	if err != nil {	playerSeason, err := svc.AddPlayerToSeason(seasonID, req)	}		return		sendError(c, errors.InvalidInput(err.Error()))	if err := c.ShouldBindJSON(&req); err != nil {	var req models.AddPlayerToSeasonRequest	seasonID := c.Param("id")func handleAddPlayerToSeason(c *gin.Context, svc *service.Service) {}	sendSuccess(c, players, http.StatusOK)	}		return		}			sendError(c, errors.DatabaseError(err))		} else {			sendError(c, appErr)		if appErr, ok := err.(*errors.AppError); ok {	if err != nil {	players, err := svc.GetPlayersBySeasonID(seasonID)	seasonID := c.Param("id")func handleGetPlayersBySeasonID(c *gin.Context, svc *service.Service) {// ==================== Player-Season Handlers ====================}	sendSuccess(c, season, http.StatusCreated)	}		return		}			sendError(c, errors.DatabaseError(err))		} else {			sendError(c, appErr)		if appErr, ok := err.(*errors.AppError); ok {	if err != nil {	season, err := svc.CreateSeason(req)	}		return		sendError(c, errors.InvalidInput(err.Error()))	if err := c.ShouldBindJSON(&req); err != nil {	var req models.CreateSeasonRequestfunc handleCreateSeason(c *gin.Context, svc *service.Service) {}	sendSuccess(c, season, http.StatusOK)	}		return		}			sendError(c, errors.DatabaseError(err))		} else {			sendError(c, appErr)		if appErr, ok := err.(*errors.AppError); ok {	if err != nil {	season, err := svc.GetSeasonByID(seasonID)	seasonID := c.Param("id")func handleGetSeasonByID(c *gin.Context, svc *service.Service) {}	sendSuccess(c, seasons, http.StatusOK)	}		return		}			sendError(c, errors.DatabaseError(err))		} else {			sendError(c, appErr)		if appErr, ok := err.(*errors.AppError); ok {	if err != nil {	seasons, err := svc.GetAllSeasons()func handleGetSeasons(c *gin.Context, svc *service.Service) {// ==================== Season Handlers ====================}	sendSuccess(c, ranks, http.StatusOK)	}		return		}			sendError(c, errors.DatabaseError(err))		} else {			sendError(c, appErr)		if appErr, ok := err.(*errors.AppError); ok {	if err != nil {	ranks, err := svc.GetAllRanks()func handleGetRanks(c *gin.Context, svc *service.Service) {// ==================== Rank Handlers ====================}	sendSuccess(c, team, http.StatusCreated)	}		return		}			sendError(c, errors.DatabaseError(err))		} else {			sendError(c, appErr)		if appErr, ok := err.(*errors.AppError); ok {	if err != nil {	team, err := svc.CreateTeam(req)	}		return		sendError(c, errors.InvalidInput(err.Error()))	if err := c.ShouldBindJSON(&req); err != nil {	var req models.CreateTeamRequestfunc handleCreateTeam(c *gin.Context, svc *service.Service) {}	sendSuccess(c, teams, http.StatusOK)	}		return		}			sendError(c, errors.DatabaseError(err))		} else {			sendError(c, appErr)		if appErr, ok := err.(*errors.AppError); ok {	if err != nil {	teams, err := svc.GetAllTeams()func handleGetTeams(c *gin.Context, svc *service.Service) {// ==================== Team Handlers ====================}	sendSuccess(c, player, http.StatusOK)	}		return		}			sendError(c, errors.DatabaseError(err))		} else {			sendError(c, appErr)		if appErr, ok := err.(*errors.AppError); ok {	if err != nil {	player, err := svc.UpdatePlayer(playerID, req)	}		return		sendError(c, errors.InvalidInput(err.Error()))	if err := c.ShouldBindJSON(&req); err != nil {	var req models.UpdatePlayerRequest	playerID := c.Param("id")func handleUpdatePlayer(c *gin.Context, svc *service.Service) {}	sendSuccess(c, player, http.StatusCreated)	}		return		}			sendError(c, errors.DatabaseError(err))		} else {			sendError(c, appErr)		if appErr, ok := err.(*errors.AppError); ok {	if err != nil {	player, err := svc.CreatePlayer(req)	}		return		sendError(c, errors.InvalidInput(err.Error()))	if err := c.ShouldBindJSON(&req); err != nil {	var req models.CreatePlayerRequestfunc handleCreatePlayer(c *gin.Context, svc *service.Service) {}	sendSuccess(c, player, http.StatusOK)	}		return		}			sendError(c, errors.DatabaseError(err))		} else {			sendError(c, appErr)		if appErr, ok := err.(*errors.AppError); ok {	if err != nil {	player, err := svc.GetPlayerByID(playerID)	playerID := c.Param("id")func handleGetPlayerByID(c *gin.Context, svc *service.Service) {}	sendSuccess(c, players, http.StatusOK)	}		return		sendError(c, err.(*errors.AppError))	if err != nil {	players, err := svc.GetAllPlayers()func handleGetPlayers(c *gin.Context, svc *service.Service) {// ==================== Player Handlers ====================}	})		"data":    data,		"success": true,	c.JSON(statusCode, gin.H{func sendSuccess(c *gin.Context, data interface{}, statusCode int) {// sendSuccess sends a successful response}	c.JSON(appErr.StatusCode, appErr)	}		log.Printf("Error: %v", appErr)	} else {		log.Printf("Error: %v (Cause: %v)", appErr, appErr.Cause)	if appErr.Cause != nil {func sendError(c *gin.Context, appErr *errors.AppError) {// sendError sends a standardized error response// ==================== Error Response Helper ====================)	"pingpong-backend/internal/service"	"pingpong-backend/internal/models"	"pingpong-backend/internal/errors"	"github.com/gin-gonic/gin"	"net/http"	"log"import (package handlers